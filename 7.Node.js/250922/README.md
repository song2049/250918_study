## 오늘 수업은 뭐할까?

> **서버는 어떻게 DB에 요청하고, 응답을 기다릴까?**
> 그 구조를 이해하려면 반드시 알아야 할 것이 하나 있다.
> 바로 **"비동기 처리"**이다.

오늘 우리는
**콜백 함수 => Promise => async/await**
으로 이어지는 **비동기 처리의 역사**를 알아보자!

이걸 모르면
**Node.js 서버를 짜도, DB 연결을 못 한다.**

---

## 오늘 수업의 핵심

- 서버는 동시에 여러 요청을 처리해야 한다
- 외부 요청은 시간이 오래 걸리기 때문에 **비동기 처리**가 필수다
- 비동기의 구조는 크게 세 단계로 발전했다:

  1. **콜백(callback)**
  2. **프로미스(Promise)**
  3. **비동기 함수(async/await)**

- 오늘 배운 구조는 **내일부터 시작되는 MySQL 수업의 기반**이 된다

---

## 오늘 수업의 목차

1. **주말 과제 복기**

   - Express + Node.js 기반 CRUD 흐름 점검

2. **내일부터는 MySQL 시작**

   - DB와 서버의 통신 구조는 전부 비동기 기반

3. **그래서 오늘은 비동기 구조 학습**

   - 서버가 응답을 기다리는 방식은 콜백 => Promise => async로 진화

4. **콜백 함수 복습 => 콜백 헬 체험**

   - 차량 출발 시뮬레이션: 소나타, 아반떼, 제네시스
   - 콜백 중첩 => 가독성 붕괴

5. **콜백 헬을 구원할 `Promise` 구조**

   - `.then()`, `.catch()`으로 흐름 제어
   - 실무에서 거의 모든 비동기 API는 Promise 기반

6. **왜 Promise 기반 API를 쓰는가?**

   - 서버는 수많은 요청을 병렬로 처리해야 하므로
   - IO는 반드시 비동기, 그래서 Promise 구조가 필수

7. **그런데 Promise도 체이닝 지옥은 피하지 못함**

   - `.then().then()`의 한계

8. **그래서 나온 ES8(2017) 문법 `async/await`**

   - 가독성, 유지보수성, 에러처리까지 모두 개선
   - 실무 서버는 거의 대부분 이 문법으로 작성

9. **예고: 내일부터 DB**

   - `await db.query(...)` 직접 쓰게 될 예정
   - 오늘 배운 흐름이 없으면, MySQL 수업은 이해 불가